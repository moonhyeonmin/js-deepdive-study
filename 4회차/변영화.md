## QnA

<details>
<summary>함수 레벨 스코프의 문제점은?</summary>

함수 블록이 아닌 코드 블록에서 선언된 변수라면 코드 블록으로 감싸져 있어도 전역변수처럼 작동한다.  
즉, 전역 변수로 선언될 확률이 높다.

</details>

<details>
<summary>

코드의 출력값은?

```jsx
var x = 'global'

function foo() {
  console.log(x) // ?
  var x = 'local'
}

foo()
```

</summary>

정답: undefined  
호이스팀은 스코프 단위로 동작하기 때문에 var x = ‘local’로 인해 x는 undefined로 초기화된 상태

</details>

<details>
<summary>var로 선언된 변수는 다른 파일에서 접근할 수 있을까?</summary>

js는 원래 파일끼리 스코프를 공유하기 때문에 그렇슴  
근데 esm으로 작성한다면 파일 자체가 독자적인 모듈 스코프를 갖기 때문에 아님

</details>

### 13장 스코프

- 스코프
  - 식별자가 유효한 범위
  - 식별자를 검색할 때 사용하는 규칙
- 식별자 결정
  - 이름이 같은 두 개의 변수중 어떤 변수를 참조해야 할지 엔진이 결정
- 스코프 체인
  - 식별자를 찾는 일련의 과정
- 블록 레벨 스코프 vs 함수 레벨 스코프
  - 블록 레벨 스코프: 코드 블록으로 감싸져 있는 경우 스코프 생성
  - 함수 레벨 스코프: 함수 코드 블록으로 감싸져 있는 경우만 스코프 생성 (함수 내부의 if문 내에서 변수가 선언되더라도 함수안에서 참조 가능하다)
  - var는 함수 레벨 스코프를 따르고, let, const는 블록 레벨 스코프를 따른다.
- 동적 스코프 vs 정적 스코프
  - 동적 스코프: 실행된 시점을 중점으로 스코프를 결정
  - 정적 스코프(=렉시컬 스코프): 선언된 시점을 중점으로 스코프를 결정 ⇒ JS
- 암묵적 전역
  - 선언하지 않은 변수에 할당할 때 오류가 나지 않고 window, global 전역객체의 프로퍼티로 저장된다.

### 14장 전역 변수의 문제점

- 호이스팅은 전역 변수에 한정됨
  - 함수내의 지역변수는 함수가 호출되면 선언되기 시작함
- 보통 함수 내 지역변수는 함수와 생명주기가 같지만 지역 변수가 함수보다 오래 생존하는 경우도 있다.
  - 함수 내 지역변수는 함수가 생성한 스코프에 등록된다. (렉시컬 스코프)
- 문제점
  - 암묵적 결합: 모든 코드가 전역 변수를 참조하고 변경할 수 있다. ⇒ 의도치 않게 상태가 변경될 수 있다.
  - 긴 생명주기: 메모리 리소스를 오랜기간 소비, 변수 이름이 중복될 가능성이 있다.
  - 스코프 체인 상의 종점에 존재: 검색 속도가 가장 느리다.
  - 네임스페이스 오염: JS는 파일이 분리되어 있어도 하나의 전역 스코프를 공유하기 때문에 다른 파일 내에 동일한 이름이 있으면 예상치 못한 결과가 있을 수 있다. (esm은 독자적인 모듈 스코프를 제공한다.)

### 15장 let, const 키워드와 블록 레벨 스코프

- let은 호이스팅이 발생하지 않는 것처럼 동작한다.
  - var는 런타임 이전에 선언 단계와 초기화 단계가 한번에 진행되지만, let은 선언 단계만 런타임 이전에 발생하고, 초기화 단계는 런타임 이후에 실행된다. (ReferrenceError가 발생하는 구간 TDZ)
