## QnA

**1) Ajax를 이용하면 변경이 필요한 부분만 요청해서 한정적으로 렌더링하는 방식이 가능해졌다고 하는데, 해당 방식이 비동기 통신과 무슨 상관이 있는가?**

<details>
<summary>정답</summary>

동기 방식 사용 시, 요청 처리 중 전체 페이지를 새로고침 해야함.
하지만 비동기 방식 사용 시, 요청 처리 중 사용자가 다른 작업을 수행할 수 있으며, 해당 요청이 완료 시 DOM API를 이용해 필요한 부분만 렌더링 할 수 있다.

</details>
<br>

**2) 브라우저 런타임 환경과, Node.js 런타임 환경의 차이는?**

<details>
<summary>정답</summary>

| **특성**              | **브라우저 런타임**                             | **Node.js 런타임**                            |
| --------------------- | ----------------------------------------------- | --------------------------------------------- |
| **주요 역할**         | 클라이언트 측에서 JavaScript 실행               | 서버 측에서 JavaScript 실행                   |
| **V8 엔진 포함 여부** | 포함됨 (크롬 브라우저)                          | 포함됨                                        |
| **추가 기능**         | DOM 조작, 이벤트 핸들링, 브라우저 API 사용 가능 | 파일 시스템, 네트워크, 데이터베이스 접근 가능 |
| **사용 가능한 API**   | `window`, `document`, `fetch`                   | `fs`, `http`, `path`, `os`                    |
| **운영체제와의 통신** | 제한적 (보안상의 이유로 파일 시스템 접근 불가)  | 파일 시스템, 소켓, 프로세스 관리 가능         |

</details>
<br>

**3) Node.js는 I/O 처리 성능이 좋다고 한다. 그러한 이유는?**

<details>
<summary>정답</summary>

I/O 처리는 CPU가 아닌 외부 자원(디스크, 네트워크 등)에서 일어난다.
비동기 I/O 지원
Non-Blocking
→ Node.js는 비동기 I/O를 지원하므로 I/O 처리를 운영체제에게 비동기적으로 위임하고, 이후 작업을 진행한다.이때, I/O 작업이 완료되면 콜백 함수를 이벤트 큐에 등록하여 결과를 처리한다. 이런 비동기 및 Non-Blocking 방식을 이용해 I/O 처리의 효율을 높인다.
이러한 방식으로 단일 스레드로도 병렬처리처럼 할 수 있으며, 이로 인해 스레드 관리 오버헤드가 줄어든다.
예제코드

```tsx
// 동기 방식
const fs = require('fs');
const data = fs.readFileSync('file.txt', 'utf8'); // 파일 읽는 동안 멈춤
console.log(data); // 파일 읽기 완료 후 출력

// 비동기 방식
const fs = require('fs');
fs.readFile('file.txt', 'utf8', (err, data) => {
  console.log(data); // 파일 읽기가 완료되면 실행
});
console.log('다음 작업'); // 파일 읽기와 동시에 실행
```

</details>
<br>

# 2장. 자바스크립트란?

### Ajax

자바스크립트는 Ajax(Asynchronous JavaScript and XML)를 이용해 비동기 방식을 사용할 수 있게 됐다.

XMLHttpRequest는 Ajax를 구현한 API다.

이런 방식으로 인해 사용자 작업 완료 시 불필요하게 페이지를 전체 다시 요청하는 것이 아닌, 필요한 부분만 요청하여 렌더링할 수 있게 되었다.

ex) 댓글을 다는 경우(GPT 예시 코드)

```html
<!-- 동기 처리 방식 -->
<form action="/add-comment" method="POST">
  <textarea name="comment"></textarea>
  <button type="submit">등록</button>
</form>
```

```tsx
// 자바스크립트를 이용한 비동기 처리 방식

// 댓글 등록 버튼 클릭 시 비동기 요청을 전송
document
  .getElementById('submit-btn')
  .addEventListener('click', function (event) {
    event.preventDefault(); // 기본 폼 제출 방지

    const comment = document.getElementById('comment-text').value;

    fetch('/add-comment', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ comment: comment }),
    })
      .then((response) => response.json())
      .then((data) => {
        // 서버 응답이 오면 댓글 영역만 업데이트
        const commentsList = document.getElementById('comments');
        commentsList.innerHTML += `<li>${data.comment}</li>`;
      })
      .catch((error) => console.error('Error:', error));
  });
```

## 자바스크립트는 인터프리터 언어지만, 컴파일을 한다?

자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어다.

인터프리터 언어는 런타임에서 한 줄 씩 바이트코드로 변환되어 컴파일 언어보다 느리다.

하지만 대부분의 요즘 자바스크립트 엔진(V8 등)은 컴파일 언어처럼 명시적인 컴파일 단계를 거치진 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행한다.

이를 통해 실행속도가 느리다는 단점을 극복했다.

# 3장. 자바스크립트 개발 환경과 실행 방법

## 3.1 자바스크립트 실행 환경

브라우저와 Node.js에서 ECMAScript 코드는 호환 가능하다.

하지만, 각 실행환경 별 지원하는 API는 호환되지 않는다. (별도의 라이브러리 사용 필요)

| **특성**              | **브라우저 런타임**                             | **Node.js 런타임**                            |
| --------------------- | ----------------------------------------------- | --------------------------------------------- |
| **주요 역할**         | 클라이언트 측에서 JavaScript 실행               | 서버 측에서 JavaScript 실행                   |
| **V8 엔진 포함 여부** | 포함됨 (크롬 브라우저)                          | 포함됨                                        |
| **추가 기능**         | DOM 조작, 이벤트 핸들링, 브라우저 API 사용 가능 | 파일 시스템, 네트워크, 데이터베이스 접근 가능 |
| **사용 가능한 API**   | `window`, `document`, `fetch`                   | `fs`, `http`, `path`, `os`                    |
| **운영체제와의 통신** | 제한적 (보안상의 이유로 파일 시스템 접근 불가)  | 파일 시스템, 소켓, 프로세스 관리 가능         |

## 3.2 웹 브라우저

크롬 짱

## 3.3 Node.js

Node.js - V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경

npm - 자바스크립트 패키지 매니저

## 3.4 비주얼 스튜디오 코드

패스

# 4장. 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

**변수**: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

→ 값은 컴퓨터 상에서 메모리에 저장이 되고, 이 값을 사용하려고 보니 직접 메모리 주소를 가지고 불러올 순 없다. 그래서 변수를 이용해 값을 저장하고 불러와 사용한다.

## 4.2 식별자

**식별자**: 어떤 값을 구별해서 식별할 수 있는 고유한 이름

변수 이름도 식별자. 이 때, 식별자는 값이 아니라 메모리 주소를 기억한다.

변수, 함수, 클래스 등과 같이 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름을 식별자 라고 한다.

## 4.3 변수 선언

```tsx
var score; // 변수 선언(변수 선언문), undefined
```

위 변수 선언문 실행 시,

1. 선언 단계: 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.

변수가 선언이 되어있어야 해당 변수를 사용할 수 있으며, 선언하지 않은 식별자 사용 시 ReferenceError가 발생한다.

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

모든 선언문(변수 선언문, 함수 선언문 등)은 가장 먼저 실행된다.

변수 선언문이 코드 맨 윗줄에서 실행되는 것처럼 동작하는 것을 **변수 호이스팅**이라 한다.

var, let, const, function, function\*, class를 사용하여 선언한 모든 식별자는 호이스팅 된다.

## 4.5 값의 할당

아래 두 코드는 동일하게 동작한다.

```tsx
var score; // 변수 선언 -> 런타임 이전에 실행
score = 80; // 값의 할당 -> 런타임에 실행
```

```tsx
var score = 80; // 변수 선언과 값의 할당 -> 분리되어 실행
```

주의1. 변수 선언과 값의 할당의 실행 시점은 변수 호이스팅에 의해 다르다.

변수 선언은 런타임 이전에 실행되고, 값의 할당은 런타임에 실행된다.

## 4.6 값의 재할당

var 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 처음 값을 할당하는 것도 엄밀히 말하면 재할당이다.

재할당 시, 변수의 메모리 공간을 해당 값으로 덮어 씌우는 것이 아닌 해당 값에 대한 메모리 공간을 새로 확보한다.

이 때 불필요하게 된 메모리 공간들은 가비지 컬렉터에 의해 자동 해제된다.

## 4.7 식별자 네이밍 규칙

- 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 숫자로 시작하지 않는다.
- 예약어는 사용 불가능하다.

# 5장. 표현식과 문

## 5.1 값

**값**: 식(표현식)이 평가되어 생성된 결과

```tsx
// 10 + 20이 평가되어 생성된 값(30)이 sum에 저장된다.
var sum = 10 + 20;
```

## 5.2 리터럴

**리터럴**: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법

## 5.3 표현식

**표현식**: 값으로 평가될 수 있는 문

```tsx
// 리터럴 표현식
10;
('Hello');

// 식별자 표현식(선언이 이미 존재한다고 가정)
sum;
person.name;
arr[1];

// 연산자 표현식
10 + 20;
sum = 10;
sum !== 10;

// 함수/메서드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName();
```

## 5.4 문

**문**: 프로그램을 구성하는 기본 단위이자 최소 실행 단위. 여러 토큰으로 구성됨

**토큰**: 문법적인 의미를 가지고, 더 이상 나눌 수 없는 코드의 기본 요소

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

문을 끝낼 때는 세미콜론(;)을 붙여야 한다.

코드 블록({ … }) 뒤에는 세미콜론을 붙이지 않는다.

자바스크립트 엔진에서는 ‘세미콜론 자동 삽입 기능’이 있어 생략 가능하다.

## 5.6 표현식인 문과 표현식이 아닌 문

변수에 할당해보면 표현식인지 아닌지 구별 가능하다.

```tsx
var x; // 표현식이 아닌 문
var foo = var x; // SyntaxError: Unexpected token var

x = 100; // 표현식인 문
var foo = x = 100; // O
```
